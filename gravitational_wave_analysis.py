# -*- coding: utf-8 -*-
"""Gravitational wave analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1noyqlvGk3TdwA4FpzMMTmdqZ8LkzFKbR

#Gravitational wave data analysis Assignment
Question 1
"""

import sys
!{sys.executable} -m pip install pycbc lalsuite ligo-common --no-cache-dir

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from pycbc.waveform import td_approximants, fd_approximants
import pylab

print(fd_approximants())

# Commented out IPython magic to ensure Python compatibility.
!wget -nc https://dcc.ligo.org/public/0146/P1700349/001/H-H1_LOSC_CLN_4_V1-1187007040-2048.gwf
!wget -nc https://dcc.ligo.org/public/0146/P1700349/001/L-L1_LOSC_CLN_4_V1-1187007040-2048.gwf



# %matplotlib inline
import pylab
from pycbc.filter import highpass
from pycbc.catalog import Merger
from pycbc.frame import read_frame

merger = Merger("GW170817")
import numpy as np
import pycbc.types 

strain, stilde = {}, {}
for ifo in['H1','L1']:
  # We'll download the data and select 256 secondsthat includes the event time
  ts =read_frame("{}-{}_LOSC_CLN_4_V1-1187007040-2048.gwf".format(ifo[0],ifo),'{}:LOSC-STRAIN'.format(ifo),start_time=merger.time -224,end_time=merger.time +32,check_integrity=False)
  # Read the detector data and remove low frequencycontent
  strain[ifo] = highpass(ts,15)
  # Remove time corrupted by the high pass filter
  strain[ifo] = strain[ifo].crop(4,4)
  # Also create a frequency domain version of the data
  stilde[ifo] = strain[ifo].to_frequencyseries()
  #print (strain.delta_t)
  pylab.plot(strain['H1'].sample_times, strain['H1'])
  pylab.xlabel('Time (s)')
  pylab.show()

from pycbc.psd import interpolate, inverse_spectrum_truncation
psds = {}
for ifo in ['L1','H1']:
# Calculate a psd from the data. We'll use 2s segments in a median -welch style estimate# We then interpolate the PSD to the desired frequencystep.
  psds[ifo] = interpolate(strain[ifo].psd(2), stilde[ifo].delta_f)
# We explicitly control how much data will be corruptedbyoverwhitening the data later on# In this case we choose 2 seconds.
  psds[ifo] = inverse_spectrum_truncation(psds[ifo],int(2*strain[ifo].sample_rate),low_frequency_cutoff=15.0,trunc_method='hann')
  pylab.loglog(psds[ifo].sample_frequencies, psds[ifo],label=ifo)
  pylab.xlim(20,1024)
  pylab.ylim(1e-47,1e-42)
pylab.legend()

from pycbc.waveform import get_fd_waveform
from pycbc.filter import matched_filter
from pycbc.conversions import mass1_from_mchirp_q
import numpy
# We will try different component masses and see whichgives us thelargest
masses = numpy.arange(1.3,1.5,.01)
# Variables to store when we've found the max
hmax, smax, tmax, mmax, nsnr = None, {}, {},0,0
snrs = []
for m in masses:
  #Generate a waveform with a given component mass;assumed equal mass,nonspinning
  hp, hc = get_fd_waveform(approximant="TaylorF2",
                           mass1=m, mass2=m,
                           f_lower=20, 
                           delta_f=stilde[ifo].delta_f)
  hp.resize(len(stilde[ifo]))
  # Matched filter the data and find the peak
  max_snr, max_time = {}, {}
  for ifo in ['L1','H1']:
    snr = matched_filter(hp, stilde[ifo], psd=psds[ifo],low_frequency_cutoff=20.0)
    # The complex SNR at the peak
    snr = snr.time_slice(merger.time -1, merger.time+1)
    _, idx = snr.abs_max_loc()
    max_snr[ifo] = snr[idx]
    # The time of the peak
    max_time[ifo] = float(idx) / snr.sample_rate+ snr.start_time
  network_snr = (abs(numpy.array(list(max_snr.values())))**2.0).sum()**0.5
  snrs.append(max_snr)
  # Keep track of only the loudest peak
  if network_snr > nsnr:
    tmax, hmax, mmax, smax = max_time, hp, m, max_snr
    nsnr = network_snr
    # See the SNR as a function of the component mass.Notice where this peaksas it gives us
    # an estimate of what the parameters of the sourcesystem are. Note thatmasses
    # here are in the *detector* frame, so if the sourceis located far away,it will in# fact correspond to a lighter system due to cosmologicalredshift.
print("We found the best Mass1=Mass2 was %2.2f solarmasses (detectorframe)"% mmax)

"""#Gravitational wave data analysis Assignment 
Question 2
"""

import numpy as np

import pycbc.types 
d = np.load('/content/drive/MyDrive/Colab Notebooks/noise_ts_4096Hz.npy')

dt = d[:, 0]
d = pycbc.types.TimeSeries(d[:, 1], delta_t = dt[1]- dt[0])
data = d

import numpy as np
import pycbc.noise
import pycbc.psd
import pycbc.filter
import pycbc.waveform
import pylab
from pycbc.psd import welch, interpolate
flow = 30
psds = interpolate(welch(d), 1.0 / d.duration)
stilde = data.to_frequencyseries()
hp, hc = pycbc.waveform.get_fd_waveform(approximant="TaylorF2",
                             mass1=10, mass2=10,
                             f_lower=flow, delta_f=stilde.delta_f)
hp.resize(len(stilde))  
snr = pycbc.filter.matched_filter(hp, stilde, psd=psds,
                                      low_frequency_cutoff=flow)
snr = snr[len(snr) // 4: len(snr) * 3 // 4]

pylab.plot(snr.sample_times, abs(snr))
pylab.ylabel('signal-to-noise ratio')
pylab.xlabel('time (s)')
pylab.show()
print ( 'Maximum SNR', max(abs(snr)) )

import pycbc.psd
from scipy.stats import norm
from pycbc.psd import welch, interpolate
import pycbc.types 
import numpy as np
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
d = np.load('/content/drive/MyDrive/Colab Notebooks/noise_ts_4096Hz.npy')

dt = d[:, 0]
d = pycbc.types.TimeSeries(d[:, 1], delta_t = dt[1]- dt[0])
1.0/d.delta_t
psds = interpolate(welch(d), 1.0 / d.duration)

data = d
white_data = (data.to_frequencyseries()/psds**0.5).to_timeseries()
white_data.crop(4,4)
x = range(-200,200,5)
 
(mu, sigma) = norm.fit(white_data)

n, bins, patches = plt.hist(white_data,x, 60, facecolor='green', alpha=0.75)


y = norm.pdf( bins, mu, sigma)
l = plt.plot(bins, y, 'r--', linewidth=2)
plt.grid(True)

plt.xlabel('whitened strain')
plt.ylabel('Probability')
plt.title(r'$\mathrm{Histogram\ of\ IQ:}\ \mu=%.3f,\ \sigma=%.3f$' %(mu, sigma))

plt.show()

from pycbc.filter import sigmasq  
from pycbc.waveform import get_fd_waveform
from pycbc.waveform import get_fd_waveform
max = 1000
hp, hc = get_fd_waveform(approximant="TaylorF2",   
                         mass1=3,                  
                         mass2=3,   
                         delta_f = 1.0/(200),              
                         #delta_f=1.0/(200.0) ,     
                         distance = 500,           
                         f_lower=20.0, f_final = 2048.0)    #Luminosity distance = 500 Mpc



slice_data = int(len(data)/max)

SNRList = []
for i in range(max):
  data_chunk = data[i*slice_data : (i+1)*slice_data]

  psds = pycbc.psd.interpolate(pycbc.psd.welch(data_chunk), hp.delta_f)

  optSNR = (pycbc.filter.sigmasq(hp, psds))**0.5

  SNRList.append(optSNR)




#SNR = (np.sum((4*hp*np.conj(hp)*hp.delta_f/psd).data).real)**0.5
#x = range(0,25,5)
plt.hist(SNRList, 100, density = True, color = 'green')
plt.show()

"""#Gravitational wave data analysis Assignment
Question 3
"""

import pycbc.psd
import numpy as np
flow = 4.0   # set up the lower cut off frequency
delta_f = 1.0 / 16
flen = int(2048.0/ (delta_f)) + 1
psd = pycbc.psd.aLIGOZeroDetHighPower(flen, delta_f, flow)
psd.data[:int(flow/delta_f)] = np.inf  #set the value outside the frequency range to infinity>>>>psd.data[-1] = np.inf

psd.data[-1] = np.inf

pylab.loglog(psd.sample_frequencies, psd)
pylab.xlim(10,2048)
pylab.ylim(1e-47, 1e-44)
pylab.show()

import pycbc.psd
import numpy as np
flow = 4.0   # set up the lower cut off frequency
delta_f = 1.0 / 16
flen = int(2048.0/ (delta_f)) + 1
psd = pycbc.psd.EinsteinTelescopeP1600143(flen, delta_f, flow)
psd.data[:int(flow/delta_f)] = np.inf  #set the value outside the frequency range to infinity
psd.data[-1] = np.inf

pylab.loglog(psd.sample_frequencies, psd)
pylab.xlim(10,2048)
pylab.ylim(1e-49, 1e-47)
pylab.show()